"""Generate a PDF based on the intermediate json output."""
import argparse
import importlib.resources
import json
import os
import tempfile
from dataclasses import dataclass, field
from datetime import date, datetime
from typing import List, Literal, Optional, Union

from dotenv import dotenv_values
from pylatex import Command, Document, FlushLeft, LongTable, MultiColumn, NoEscape, Section, Subsection, Subsubsection
from pylatex.utils import bold


@dataclass
class Detail:
    """A message logged by ``pdf_report.detail``."""

    message: str
    timestamp: float


@dataclass
class Step:
    """A step created by ``pdf_report.step``."""

    message: str
    details: List[Detail] = field(default_factory=list)


@dataclass
class Result:
    """A single test execution.

    This combines the setup, call teardown phases, which appear as separate
    lines in the report.json file.
    """

    nodeid: str
    name: str
    blurb: str
    steps: List[Step] = field(default_factory=list)
    outcome: Literal["passed", "failed", "skipped"] = "failed"
    failure_message: Optional[str] = None
    duration: float = 0.0


def parse(input_data: list) -> List[Result]:
    """Parse the data written by pytest-reportlog.

    The JSON must already have been parsed in `input_data`.
    """
    results = []
    for line in input_data:
        if line["$report_type"] != "TestReport":
            continue
        nodeid = line["nodeid"]
        if not results or results[-1].nodeid != nodeid:
            # It's the first time we've seen this nodeid (otherwise we merge
            # with the existing Result).
            results.append(Result(nodeid, line["location"][2], ""))
        result = results[-1]
        # The teardown phase has all the log messages, so we ignore the setup and call phases.
        if line["when"] == "teardown":
            for prop in line["user_properties"]:
                if prop[0] == "pdf_report_data":
                    for msg in prop[1][:]:
                        msg_type = msg["$msg_type"]
                        if msg_type == "step":
                            details = [Detail(detail["message"], detail["timestamp"]) for detail in msg["details"]]
                            result.steps.append(Step(msg["message"], details))
                        elif msg_type == "test_info":
                            if not result.blurb:
                                result.blurb = msg["blurb"]
                        else:
                            raise ValueError(f"Do not know how to parse $msg_type of {msg_type!r}")
        # If teardown fails, the whole test should be seen as failing
        if line["outcome"] != "passed" or line["when"] == "call":
            result.outcome = line["outcome"]
        # The test duration will be the sum of setup, call and teardown.
        result.duration += line["duration"]
        try:
            failure_message = line["longrepr"]["reprcrash"]["message"]
        except (KeyError, TypeError):
            pass
        else:
            # TODO: if multiple phases have failure messages, we probably want to
            # collect them all. We could also collect the more detailed messages.
            result.failure_message = failure_message
    return results


def fix_test_name(test_name: str) -> str:
    """Change a test's name from a pytest one to a more human-friendly one."""
    return " ".join([word.capitalize() for word in test_name.split("_") if word != "test"])


def document_from_json(input_data: Union[str, list]) -> Document:
    """Take a test result and generate a :class:`pylatex.Document` for a report.

    Parameters
    ----------
    input_data
        Either the list of parsed JSON entries, or a path to the report file
        generated by :samp:`pytest --report-log={filename}`.

    Returns
    -------
    doc
        A document
    """
    try:
        result_list = []
        with open(input_data) as fp:
            for line in fp:
                result_list.append(json.loads(line))
    except TypeError:
        result_list = input_data
    results = parse(result_list)

    # Get information from the .env file, such as tester's name, which shouldn't
    # really be in git.
    config = {**dotenv_values(), **os.environ}  # Get values from .env file, allow environment to override

    doc = Document(
        document_options=["11pt", "english", "twoside"],
        inputenc=None,  # katdoc inputs inputenc with specific options, so prevent a clash
    )
    today = date.today()  # TODO: should store inside the JSON
    doc.set_variable("theAuthor", config.get("TESTER_NAME", "Unknown"))
    doc.set_variable("docDate", today.strftime("%d %B %Y"))
    doc.preamble.append(NoEscape(importlib.resources.read_text("pdf_logger", "preamble.tex")))
    doc.append(Command("title", "Integration Test Report"))
    doc.append(Command("makekatdocbeginning"))
    # TODO: Add a summary table.
    with doc.create(Section("Test Results")) as section:
        for result in results:
            with section.create(Subsection(fix_test_name(result.name))):
                section.append(result.blurb)
                with section.create(Subsubsection("Summary", label=False)) as summary:
                    summary.append(bold(f"Test {result.outcome}\n\n"))
                    summary.append(f"Test duration: {result.duration:.3f} seconds\n")  # TODO: handle minutes / hours
                with section.create(Subsubsection("Procedure", label=False)) as procedure:
                    with section.create(LongTable(r"|l|p{0.7\linewidth}|")) as procedure_table:
                        for step in result.steps:
                            procedure_table.add_hline()
                            procedure_table.add_row((MultiColumn(2, align="|l|", data=bold(step.message)),))
                            procedure_table.add_hline()
                            for detail in step.details:
                                # TODO: timestamps for the actual steps.
                                procedure_table.add_row(
                                    [datetime.fromtimestamp(float(detail.timestamp)).strftime("%T.%f"), detail.message]
                                )
                                procedure_table.add_hline()

                    if result.failure_message:
                        with procedure.create(FlushLeft()) as failure_message:
                            failure_message.append(result.failure_message)

    return doc


def main():
    """Convert a JSON report to a PDF."""
    parser = argparse.ArgumentParser()
    parser.add_argument("input", help="Output of pytest --report-log=...")
    parser.add_argument("pdf", help="PDF file to write")
    args = parser.parse_args()
    doc = document_from_json(args.input)
    if args.pdf.endswith(".pdf"):
        args.pdf = args.pdf[:-4]  # Strip .pdf suffix, because generate_pdf appends it
    with tempfile.NamedTemporaryFile(mode="w", prefix="latexmkrc") as latexmkrc:
        with importlib.resources.path("pdf_logger", "katdoc.sty") as katdoc_sty_path:
            # TODO: latexmk uses Perl, which has different string parsing to
            # Python. If the path contains both a single quote and a special
            # symbol it will not produce a valid Perl string.
            parent_dir = str(katdoc_sty_path.parent)
            latexmkrc.write(f"ensure_path('TEXINPUTS', {parent_dir!r})\n")
            latexmkrc.flush()
            doc.generate_pdf(args.pdf, compiler="latexmk", compiler_args=["--pdf", "-r", latexmkrc.name])
