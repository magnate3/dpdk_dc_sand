"""Coefficient generator for unit tests."""
import numpy as np


class CoeffGenerator:
    """Class for generating coefficients for testing purposes.

    Note: The coefficients for this feature will be supplied by CAM and are not
    generated by CBF.

    Parameters
    ----------
    batches: int
        The number of matrices to be reordered, a single data matrix = one batch.
    n_channels: int
        The number of frequency channels to be processed.
    n_blocks: int
        The number of blocks that each channels set of samples are divided into.
    samples_per_block: int
        The number of time samples to be processed per block.
    n_ants: int
        The number of antennas that will be used in beamforming. Each antennas is expected to produce two polarisations.
    """

    def __init__(self, batches, n_channels, n_blocks, samples_per_block, n_ants, xeng_id):
        """Initialise the coefficient generation class."""
        self.batches = batches
        self.n_channels = n_channels
        self.n_blocks = n_blocks
        self.samples_per_block = samples_per_block
        self.n_ants = n_ants
        self.pols = 2  # Always
        self.complexity = 2  # Always
        self.xeng_id = xeng_id
        self.total_length = self.batches * self.pols * self.n_channels * self.n_blocks * self.samples_per_block

        # Static coefficient values for testing
        self.real_coeff_value = 4
        self.imag_coeff_value = 1

    def GPU_Coeffs_cublas(self):
        """Generate coefficients for complex multiplication.

        Note: This is for use in complex multiplication using two
        real-valued arrays. For this reason the coefficients need to be
        arranged as follows.

        Coefficients Array:
        [R00  I00
         -I00 R00
         R10  I10
         -I10 R10
         ...  ...]
        Where:  R00 = Real coeff 0
                I00 = Imag coeff 0
        and the matrix is structured as a N x 2 array.

        Returns
        -------
        coeffs: np.ndarray[np.float].
            Output array of test coefficients.
        """
        coeffs = np.empty(((self.n_ants * 2) * 2 * self.total_length), dtype=np.float32).reshape(
            self.total_length, 2, self.n_ants * 2
        )
        for i in range(coeffs.shape[0]):
            for j in range(coeffs.shape[1]):
                for k in range(coeffs.shape[2]):
                    if j == 0:
                        if k % 2:
                            coeffs[i, j, k] = -1 * self.imag_coeff_value
                        else:
                            coeffs[i, j, k] = self.real_coeff_value
                    else:
                        if k % 2:
                            coeffs[i, j, k] = self.real_coeff_value
                        else:
                            coeffs[i, j, k] = self.imag_coeff_value
        return coeffs

    def GPU_Coeffs_kernel(self):
        """Generate coefficients for complex multiplication on the GPU.

        Note: This is for use in complex multiplication using two
        real-valued arrays. For this reason the coefficients need to be
        arranged as follows.

        Coefficients Array:
        [R00  I00
         -I00 R00
         R10  I10
         -I10 R10
         ...  ...]
        Where:  R00 = Real coeff 0
                I00 = Imag coeff 0
        and the matrix is structured as a N x 2 array.

        Returns
        -------
        coeffs: np.ndarray[np.float32].
            Output array of test coefficients.
        """
        coeffs = np.empty(((self.n_ants * 2) * 2 * self.total_length), dtype=np.float32).reshape(
            self.total_length, 2, self.n_ants * 2
        )
        for i in range(coeffs.shape[0]):
            for j in range(coeffs.shape[1]):
                for k in range(coeffs.shape[2]):
                    if j == 0:
                        if k % 2:
                            coeffs[i, j, k] = -1 * self.imag_coeff_value
                        else:
                            coeffs[i, j, k] = self.real_coeff_value
                    else:
                        if k % 2:
                            coeffs[i, j, k] = self.real_coeff_value
                        else:
                            coeffs[i, j, k] = self.imag_coeff_value
        return coeffs.reshape(
            self.batches,
            self.pols,
            self.n_channels,
            self.n_blocks,
            self.samples_per_block,
            2,
            self.n_ants * self.complexity,
        )

    def CPU_Coeffs(self):
        """Generate coefficients for complex multiplication on the CPU.

        Note: This is for use in complex multiplication. The real and imaginary
        values need to be interleaved as <real,imag>

        Returns
        -------
        coeffs: np.ndarray[np.float32].
            Output array of test coefficients.
        """
        coeffs = np.empty(self.n_ants * 2 * self.total_length, dtype=np.float32).reshape(
            self.total_length, self.n_ants, 2
        )
        coeffs[:, :] = [self.real_coeff_value, self.imag_coeff_value]

        return coeffs.reshape(
            self.batches, self.pols, self.n_channels, self.n_blocks, self.samples_per_block, self.n_ants, 2
        )
