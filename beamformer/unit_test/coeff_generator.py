"""Coefficient generator for unit tests."""
import numpy as np
import math

class CoeffGenerator:
    """Class for generating coefficients for testing purposes.

    Note: The coefficients for this feature will be supplied by CAM and are not
    generated by CBF.

    Parameters
    ----------
    batches: int
        The number of matrices to be reordered, a single data matrix = one batch.
    n_channels: int
        The number of frequency channels to be processed.
    n_blocks: int
        The number of blocks that each channels set of samples are divided into.
    samples_per_block: int
        The number of time samples to be processed per block.
    n_ants: int
        The number of antennas that will be used in beamforming. Each antennas is expected to produce two polarisations.
    """

    def __init__(self, batches, n_channels, n_blocks, samples_per_block, n_ants, xeng_id):
        """Initialise the coefficient generation class."""
        self.batches = batches
        self.n_channels = n_channels
        self.n_blocks = n_blocks
        self.samples_per_block = samples_per_block
        self.n_ants = n_ants
        self.pols = 2  # Always
        self.complexity = 2  # Always
        self.xeng_id = xeng_id
        self.total_length = self.batches * self.pols * self.n_channels * self.n_blocks * self.samples_per_block

        # Static coefficient values for testing
        self.real_coeff_value = 4
        self.imag_coeff_value = 1

    def GPU_Coeffs_cublas(self):
        """Generate coefficients for complex multiplication.

        Note: This is for use in complex multiplication using two
        real-valued arrays. For this reason the coefficients need to be
        arranged as follows.

        Coefficients Array:
        [R00  I00
         -I00 R00
         R10  I10
         -I10 R10
         ...  ...]
        Where:  R00 = Real coeff 0
                I00 = Imag coeff 0
        and the matrix is structured as a N x 2 array.

        Returns
        -------
        coeffs: np.ndarray[np.float].
            Output array of test coefficients.
        """
        coeffs = np.empty(((self.n_ants * 2) * 2 * self.total_length), dtype=np.float32).reshape(
            self.total_length, 2, self.n_ants * 2
        )
        for i in range(coeffs.shape[0]):
            for j in range(coeffs.shape[1]):
                for k in range(coeffs.shape[2]):
                    if j == 0:
                        if k % 2:
                            coeffs[i, j, k] = -1 * self.imag_coeff_value
                        else:
                            coeffs[i, j, k] = self.real_coeff_value
                    else:
                        if k % 2:
                            coeffs[i, j, k] = self.real_coeff_value
                        else:
                            coeffs[i, j, k] = self.imag_coeff_value
        return coeffs

    def GPU_Coeffs_kernel(self):
        """Generate coefficients for complex multiplication on the GPU.

        Note: This is for use in complex multiplication using two
        real-valued arrays. For this reason the coefficients need to be
        arranged as follows.

        Coefficients Array:
        [R00  I00
         -I00 R00
         R10  I10
         -I10 R10
         ...  ...]
        Where:  R00 = Real coeff 0
                I00 = Imag coeff 0
        and the matrix is structured as a N x 2 array.

        Returns
        -------
        coeffs: np.ndarray[np.float32].
            Output array of test coefficients.
        """
        coeffs = np.empty(((self.n_ants * 2) * 2 * self.total_length), dtype=np.float32).reshape(
            self.total_length, 2, self.n_ants * 2
        )
        for i in range(coeffs.shape[0]):
            for j in range(coeffs.shape[1]):
                for k in range(coeffs.shape[2]):
                    if j == 0:
                        if k % 2:
                            coeffs[i, j, k] = -1 * self.imag_coeff_value
                        else:
                            coeffs[i, j, k] = self.real_coeff_value
                    else:
                        if k % 2:
                            coeffs[i, j, k] = self.real_coeff_value
                        else:
                            coeffs[i, j, k] = self.imag_coeff_value
        return coeffs.reshape(
            self.batches,
            self.pols,
            self.n_channels,
            self.n_blocks,
            self.samples_per_block,
            2,
            self.n_ants * self.complexity,
        )

    def CPU_Coeffs(self, delay_vals, batches, pols, n_beams, num_channels, total_channels, n_ants, xeng_id, sample_period):

        complexity = 2
        cols = 2

        coeff_matrix = np.empty(batches*pols*num_channels*n_ants*n_beams*complexity*cols, dtype=np.float32)
        coeff_matrix = coeff_matrix.reshape(batches, pols, num_channels, n_ants*complexity, n_beams*cols)

        for iBatchIndex in range(batches):
            for iPolIndex in range(pols):
                for iChannelIndex in range(num_channels):
                    for iBeamIndex in range(n_beams):
                        for iAntIndex in range (n_ants):
                            Delay_s = delay_vals[iChannelIndex][iBeamIndex][iAntIndex][0]
                            DelayRate_sps = delay_vals[iChannelIndex][iBeamIndex][iAntIndex][1]
                            Phase_rad = delay_vals[iChannelIndex][iBeamIndex][iAntIndex][2]
                            PhaseRate_radps = delay_vals[iChannelIndex][iBeamIndex][iAntIndex][3]

                            # Compute actual channel index (i.e. channel in spectrum being computed on)
                            # This is needed when computing the rotation value before the cos/sin lookup.
                            # There are n_channels per xeng so adding n_channels * xeng_id gives the
                            # relative channel in the spectrum the xeng GPU thread is working on.
                            # iChannel = iChannelIndex//(batches*pols) + n_channels * xeng_id
                            iChannel = iChannelIndex + num_channels * xeng_id

                            # part_1 =  delay_CAM * channel_num_i * -pi  / (total_channels * sampling_rate_nanosec) +  phase_offset_CAM
                            initial_phase = Delay_s * iChannel * (-np.math.pi) / (total_channels * sample_period) + Phase_rad

                            # Then:
                            # Phase_correction_band_center = Delay_CAM * (total_channels/2) * -pi / (total_channels * sampling_rate_nanosec)
                            Phase_correction_band_center = Delay_s * (total_channels / 2) * (-np.math.pi) / (total_channels * sample_period)

                            # Calculate rotation value
                            Rotation = initial_phase - Phase_correction_band_center

                            # Compute Steering Coeffs
                            SteeringCoeffCorrectReal = math.cos(Rotation)
                            SteeringCoeffCorrectImag = math.sin(Rotation)

                            iAntMatrix = iAntIndex * 2
                            iBeamMatrix = iBeamIndex * 2

                            # Store coeffs in return matrix
                            coeff_matrix[iBatchIndex][iPolIndex][iChannelIndex][iAntMatrix][iBeamMatrix+1] = SteeringCoeffCorrectImag #1
                            coeff_matrix[iBatchIndex][iPolIndex][iChannelIndex][iAntMatrix][iBeamMatrix] = SteeringCoeffCorrectReal #4

                            coeff_matrix[iBatchIndex][iPolIndex][iChannelIndex][iAntMatrix+1][iBeamMatrix+1] = SteeringCoeffCorrectReal #4
                            coeff_matrix[iBatchIndex][iPolIndex][iChannelIndex][iAntMatrix+1][iBeamMatrix] = -SteeringCoeffCorrectImag #-1
        return coeff_matrix

    def CPU_dummy_coeffs(self):
        """Generate coefficients for complex multiplication on the CPU.

        Note: This is for use in complex multiplication. The real and imaginary
        values need to be interleaved as <real,imag>

        Returns
        -------
        coeffs: np.ndarray[np.float32].
            Output array of test coefficients.
        """
        coeffs = np.empty(self.n_ants * 2 * self.total_length, dtype=np.float32).reshape(
            self.total_length, self.n_ants, 2
        )
        coeffs[:, :] = [self.real_coeff_value, self.imag_coeff_value]

        return coeffs.reshape(
            self.batches, self.pols, self.n_channels, self.n_blocks, self.samples_per_block, self.n_ants, 2
        )
