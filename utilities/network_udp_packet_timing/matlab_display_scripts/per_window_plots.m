%% This script presents the results generated by a ./upd_receive program 
%% run with -c flag. This flag produces results per window. 
%%
%% This script reports on the number of window overlaps that occur and 
%% the number of packet drops. Additionally it plots the difference between
%% transmission and receive time per client to easily determine where large
%% unexpected delays occur. For T=3 it shows a plot of how the windows 
%% shift over time.
%% 
%% @Author: Gareth Callanan

clear all
close all
format longEng

%% Eight hour long test to examine system stability
%fileName = "8HourTest_N200000_W49000_D1000_T3.csv";

%% The three files below were prouced by testing the system under load.
%% The 50MinBusyTestBaseline test was run without any load on the system.
%% The 50MinBusyTestPriority test was run under load using the chrt utility
%% to give the network client a real time priority 
%% The 50MinBusyTestNoPriority was run under load using with the default
%% process priority 
%fileName = "50MinBusyTestBaseline_N20000_W49000_D1000_T3.csv"
%fileName = "50MinBusyTestNoPriority_N20000_W49000_D1000_T3.csv"
fileName = "50MinBusyTestPriority_N20000_W49000_D1000_T3.csv"

M = csvread(fileName);

%Metadata has been encoded in the file name.
WindowLength_us = str2double(extractBetween(fileName,"_W","_D"));
DeadTime_us = str2double(extractBetween(fileName,"_D","_T"));
NumberOfClients = str2double(extractBetween(fileName,"_T",".csv"));
WindowsPerClient = str2double(extractBetween(fileName,"_N","_W"));

%Columns information in the file - I am only extracting what I need
clientIndex = M(:,2);
windowIndex = M(:,3);
missingPacketsArr = M(:,5);
overlappingPacketsFrontArr = M(:,12);
dataRate_Gbps = M(:,8);
avgTransmitTime = M(:,9);
minTransmitTime = M(:,10);
maxTransmitTime = M(:,11);
maxVal = max(maxTransmitTime);
minVal = min(minTransmitTime);
totalPacketsReceived = sum(M(:,4));

sPerGroupOfWindows = (WindowLength_us + DeadTime_us) * NumberOfClients/1000000.0;

cols=1;
rows=floor((NumberOfClients-0.1)/cols) + 1;

%Display Run Information
disp("Clients: " + string(NumberOfClients)) 
disp("Window length(us): " + string(WindowLength_us))
disp("Dead Time between windows(us): " + string(DeadTime_us))
disp("Number of windows per client: " + string(WindowsPerClient))
disp("Total Packets Received: " + totalPacketsReceived)
runTime_us = ((WindowLength_us + DeadTime_us) * WindowsPerClient * NumberOfClients);
runTime_s = floor((WindowLength_us + DeadTime_us) * WindowsPerClient * NumberOfClients/1000000);
runTime_remaining_us = runTime_us - runTime_s*1000000;
timeString = string(datestr(seconds(runTime_s),'HH:MM:SS.'));
fprintf("Running Time: %s%06d\n\n",timeString,runTime_remaining_us)

%Check no packet drops occured 
missingPacketsTotal = sum(missingPacketsArr);
if(missingPacketsTotal == 0)
    disp("No packets missing")
else
    disp("ISSUE: " + missingPacketsTotal + " Packets were dropped.");
    missingPacketsTotalSkipFront = sum(missingPacketsArr(20:end));
    if missingPacketsTotalSkipFront == 0
       %This is expected at the start as all processes are waking up from
       %sleep state
       disp("    These missing packets only occured in the first 10 windows. No need for further investigation.") 
    else
       
       disp("    This needs further investigation: " + missingPacketsTotalSkipFront)  
    end
end

%Check no windows are overlapping
overlappingPacketsFrontTotal = sum(overlappingPacketsFrontArr);
if(overlappingPacketsFrontTotal == 0)
    disp("No packets overlapping")
else
    onePacketOverlap = sum(overlappingPacketsFrontArr == 1);
    twoPacketOverlap = sum(overlappingPacketsFrontArr == 2);
    remaining = sum(overlappingPacketsFrontArr ~= 0 & overlappingPacketsFrontArr ~= 1 & overlappingPacketsFrontArr ~= 2  );
    max = max(overlappingPacketsFrontArr(overlappingPacketsFrontArr ~= 0 & overlappingPacketsFrontArr ~= 1 & overlappingPacketsFrontArr ~= 2  ));
    disp("ISSUE: " + overlappingPacketsFrontTotal + " Packet Overlaps occured. Investigate this.");
    disp("    Windows with a single packet of overlap: " + onePacketOverlap)
    disp("    Windows with two packets of overlap: " + twoPacketOverlap)
    disp("    Windows with more than two packets of overlap: " + remaining + " Maximum number of overlapping packets: " + max)
end

%Plot Tranmission Times
for i = 1:NumberOfClients
    clientXAxis = windowIndex(clientIndex == i-1);%*sPerGroupOfWindows;
    clientMin = minTransmitTime(clientIndex == i-1)*1000000;
    clientAvg = avgTransmitTime(clientIndex == i-1)*1000000;
    clientMax = maxTransmitTime(clientIndex == i-1)*1000000;
    
    subplot(rows,cols,i)
    hold on
    plot(clientXAxis,clientMin);
    plot(clientXAxis,clientAvg);
    plot(clientXAxis,clientMax);
    grid on
    xlim([1200 2000])
    ylim([0 6000])
    title(("Client " + string(i)))
    xlabel("Window Index")
    ylabel("Travel Time(us)")
    legend('Min','Avg','Max')
    %ylim([minVal-0.0001 maxVal+0.0001]*1000000)
end

%Plot Data Rates
figure
for i = 1:NumberOfClients
    clientXAxis = windowIndex(clientIndex == i-1);%*sPerGroupOfWindows;
    clientDataRate = dataRate_Gbps(clientIndex == i-1);
    
    subplot(rows,cols,i)
    hold on
    plot(clientXAxis,clientDataRate);
    title(("Client " + string(i)))
    xlabel("Time of Window Transfer(s)")
    ylabel("Data Rate(Gbps)")
    ylim([0 15])
    %ylim([minVal-0.0001 maxVal+0.0001]*1000000)
end

% Special Case When T=3, it can be extended to different numbers of
% clients, I have just not got to it yet.
if NumberOfClients == 3
    figure
    StartTxTime_s = M(:,14);
    EndTxTime_s = M(:,15);
    StartRxTime_s = M(:,16);
    EndRxTime_s = M(:,17);

    firstTimeStamp = round(StartTxTime_s(1));

    step_s = (WindowLength_us + DeadTime_us) * NumberOfClients/1000000.0;

    Client1XAxis = windowIndex(clientIndex == 0);
    Client1ExpectedRxStart_s = Client1XAxis.*step_s;
    Client1StartRxTime_s = StartRxTime_s(clientIndex == 0) - firstTimeStamp;
    Client1EndRxTime_s = EndRxTime_s(clientIndex == 0) - firstTimeStamp;

    Client1NormalisedStartRxTime_s = Client1StartRxTime_s - Client1ExpectedRxStart_s;
    Client1NormalisedEndRxTime_s = Client1EndRxTime_s - Client1ExpectedRxStart_s;

    Client2XAxis = windowIndex(clientIndex == 1);
    Client2ExpectedRxStart_s = Client2XAxis.*step_s;
    Client2StartRxTime_s = StartRxTime_s(clientIndex == 1) - firstTimeStamp;
    Client2EndRxTime_s = EndRxTime_s(clientIndex == 1) - firstTimeStamp;

    Client2NormalisedStartRxTime_s = Client2StartRxTime_s - Client2ExpectedRxStart_s;
    Client2NormalisedEndRxTime_s = Client2EndRxTime_s - Client2ExpectedRxStart_s;

    Client3XAxis = windowIndex(clientIndex == 2);
    Client3ExpectedRxStart_s = Client3XAxis.*step_s;
    Client3StartRxTime_s = StartRxTime_s(clientIndex == 2) - firstTimeStamp;
    Client3EndRxTime_s = EndRxTime_s(clientIndex == 2) - firstTimeStamp;

    Client3NormalisedStartRxTime_s = Client3StartRxTime_s - Client3ExpectedRxStart_s;
    Client3NormalisedEndRxTime_s = Client3EndRxTime_s - Client3ExpectedRxStart_s;

    hold on
    grid on

    Client1CurveXAxis = [Client1XAxis; flip(Client1XAxis)];
    Client1InBetween = [Client1NormalisedStartRxTime_s; flip(Client1NormalisedEndRxTime_s)];
    h = fill(Client1CurveXAxis, Client1InBetween, 'r');
    set(h,'facealpha',.25)

    Client2CurveXAxis = [Client2XAxis; flip(Client2XAxis)];
    Client2InBetween = [Client2NormalisedStartRxTime_s; flip(Client2NormalisedEndRxTime_s)];
    h = fill(Client2CurveXAxis, Client2InBetween, 'b');
    set(h,'facealpha',.25)

    Client3CurveXAxis = [Client3XAxis; flip(Client3XAxis)];
    Client3InBetween = [Client3NormalisedStartRxTime_s; flip(Client3NormalisedEndRxTime_s)];
    h = fill(Client3CurveXAxis, Client3InBetween, 'g');
    set(h,'facealpha',.25)

    Client1CurveXAxis = [Client1XAxis(1:end-1); flip(Client1XAxis(1:end-1))];
    Client1InBetween = [Client1NormalisedStartRxTime_s(2:end)+step_s; flip(Client1NormalisedEndRxTime_s(2:end)+step_s)];
    h = fill(Client1CurveXAxis, Client1InBetween, 'r');
    set(h,'facealpha',.25)

    h1 = plot(Client1XAxis,Client1NormalisedStartRxTime_s,'r',Client1XAxis,Client1NormalisedEndRxTime_s,'r');
    h2 = plot(Client2XAxis,Client2NormalisedStartRxTime_s,'b',Client2XAxis,Client2NormalisedEndRxTime_s,'b');
    h3 = plot(Client3XAxis,Client3NormalisedStartRxTime_s,'g',Client3XAxis,Client3NormalisedEndRxTime_s,'g');
    plot(Client1XAxis(1:end-1),Client1NormalisedStartRxTime_s(2:end)+step_s,'r',Client1XAxis(1:end-1),Client1NormalisedEndRxTime_s(2:end)+step_s,'r');
    legend(["Client 1","Client 2","Client 3"],"Location","SouthEast")
    ylabel("Offset within Window(seconds)")
    xlabel("Window Index")

    ylim([0.0 0.175])
    %xticks(Client1XAxis.*step_s)
    yticks([0 0.025 0.05 0.075 0.1 0.125 0.15 0.175])
    yticklabels({'Window Start','0.025','0.05','0.075','0.1','0.125','Window End','0.175'})
end